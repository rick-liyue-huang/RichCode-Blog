<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>

    /*
    * a reference value (object) is an instance of a specific reference type. reference type are structure used to
    * group data and functionality together.
    * objects are considered to be instances of a particular reference type. new objects are created by using the new operator followed
    * by a constructor.
    *
    *
    * there are two ways to explicitly create an instance of Object, the first one is to use the new operator
    * the other way is to use object literal notation
    * */

    var person = new Object();
    person.name = "rick";
    person.age = 20;

    var person1 = {
        name: "leo",
        age: 23
    };

    // we also can do that
    var person2 = {};
    person2.name = "leo";
    person2.age = 29;

    // we tend to favor object literal notation, because it require less code and visual encapsulation all related data.

    function displayInfo(args) {
        var output = "";

        if (typeof args.name == "string") {
            output += "name: " + args.name + "\n";
        }

        if (typeof args.age == "number") {
            output += "age: " + args.age + "\n";
        }
        console.log(output);
    }

    displayInfo({
        name: "leo",
        age: 30
    });

    displayInfo({
        name: "greg"
    });

    // dot notation and bracket notation, we use bracket notation when the property name contains character that would
    // be either a syntax error or a keyword/reserved word
    person["fisrt name"] = "rick";

    /*
    * arrays are ordered lists of data, and can hold any type of data in each slot.
    * arrays can be created in two basic ways, the first is to use the array constructor
    * the second way to create an array is by using array literal
    * */

    var colors = new Array(3); // create an array with three item
    var names = new Array("rick"); // create an array with one item, the string rick

    var colors1 = ['red', 'blue', 'yellow'];

    // length property is very important
    colors[colors.length] = 'black';
    colors[colors.length] = 'blue';
    console.log(colors); [,,,'black', 'blue'];

    // all objects have toLocalString(), toString(), valueOf() methods, the toString() and valueOf() methods return
    //the same value when called on an array. The result is a comma-separated string that contains the string equivalents of
    // each value in the array.

    var colors = ['red', 'blue', 'green'];
    console.log(colors.toString()); // red, blue, green
    console.log(colors.valueOf()); // red, blue, green

    /*
    * its possible to construct a string with a different separator using the join() method
    * */

    var colors = ["red", 'green', 'blue'];
    console.log(colors.join(','));
    console.log(colors.join('|')); // red|green|blue

    /*
    * stack method
    * a stack is referred to as a last-in-first-out structure. The insertion (push) and removal (pop) of items in a stack
     * occur at only one point: the top of the stack.
    * the push() method accepts any number of arguments and adds them to the end of the array, returning the array's new
    * length. the pop() method removes the last item in the array, decrements the arrays length, and returns the item.
    * */

    var colors = new Array();
    var count = colors.push('red', 'blue');
    console.log(colors);
    console.log(count); // 2

    var item = colors.pop();
    console.log(item); // blue
    console.log(colors.length); // 1

    // just remember that: push() will return the length, and pop() will return the removed item.

    /*
    * queue method: first in first out data structure.
    *
    * */

    var colors = new Array();
    var count = colors.push('red', 'black');
    console.log(count); // 2
    count = colors.push('green');
    var item = colors.shift();
    console.log(item); // red---- the first item
    console.log(colors.length); // 2

    var colors = new Array();
    var count = colors.unshift('red', 'green');
    console.log(colors);
    count = colors.unshift('black');
    console.log(colors); // black red green
    var item = colors.pop();
    console.log(item); // green

    /*
    * reorder methods
    * reverse() and sort()
    * */

//    var values = [1,2,3,4,5];
//    values.reverse();
//    console.log(values); // 5,4,3,2,1
//
//    var values = [0, 1, 5, 10, 15];
//    values.sort();
//    console.log(values);

    /*
    * a comparison function used to accepts two arguments
    *
    * */

    function compare(value1, value2) {
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    }

    var values = [0, 1, 15, 10, 5];
    values.sort(compare);
    console.log(values); // 0 1 5 10 15

    function compare(value1, value2) {
        if (value1 < value2) {
            return 1;
        } else if (value1 > value2) {
            return -1;
        } else {
            return 0;
        }
    }

    function compare(val1, val2) {
        return val1 - val2;
    }
    var values = [0, 1, 15, 10, 5];
    values.sort(compare);
    console.log(values); // 0 1 5 10 15


    /*
    * manipulate method
    * concat() method, allow to create a new array based on all of the items in current array,
    * this method begins by creating a copy of the array and then appending the method arguments to the end and return
    * the newly constructed array.
    * */

    var colors = ['red', 'green', 'blue'];
    var colors2 = colors.concat('yellow', ['black', 'brown']);
    console.log(colors); //["red", "green", "blue"]
    console.log(colors2); //["red", "green", "blue", "yellow", "black", "brown"]

    /*
    * slice() method create an array that contains one or more items already contained in an array, the slice() may accept
    * one or two arguments: the start and stopping positions of the items to return. if only one argument is present, the method
    * will return the all items between that position and the end of the array.
    *
    * slice(-2, -1) === slice(3, 4),
    * */

    var colors = ['red', 'green', 'blue', 'yellow', 'purple'];
    var colors2 = colors.slice(1);
    var colors3 = colors.slice(1, 4); // does not include the end position.
    console.log(colors);
    console.log(colors2); // ["green", "blue", "yellow", "purple"]
    console.log(colors3); // ["green", "blue", "yellow"]


    /*
    * the most method is splice(), which can be used in a variety of ways
    *
    * deletion --- any number of items can be deleted from the array by specifying just two arguments, the position of the
    * first item to delete and the number of items to delete.
    *
    * insertion --- items can be inserted into a specific position by providing three or more arguments: the starting position,
    * 0 the number to be deleted, and the items to be inserted.
    *
    * replacement -- items can be replaced the deleted items by inserting the new items
    *
    * */

    var colors = ['red', 'green', 'blue'];
    var removed = colors.splice(0,1);
    console.log(colors); // green blue
    console.log(removed); // red

    removed = colors.splice(1, 0, 'yellow', 'orange');
    console.log(colors); // ["green", "yellow", "orange", "blue"]
    console.log(removed); // []

    removed = colors.splice(1, 1, 'red', 'purple');
    console.log(colors); // ["green", "red", "purple", "orange", "blue"]
    console.log(removed); // yellow

    /*
    * location method
    *
    * indexOf() and lastIndexOf()
    *
    * the methods each return the position of the item in the array or -1 if the item is not in the array
    *
    * */
    var numbers = [1,2,3,4,5,4,3,2,1];
    console.log(numbers.indexOf(4)); //3 alert(numbers.lastIndexOf(4)); //5
    console.log(numbers.indexOf(4, 4)); //5 alert(numbers.lastIndexOf(4, 4)); //3
    var person = { name: 'Nicholas'};
    var people = [{ name: 'Nicholas'}];

    var morePeople = [person];
    console.log(people.indexOf(person)); //-1
    console.log(morePeople.indexOf(person)); //0


    /*
    * iterative method
    *
    * every() -- runs the given function on every item in the array and return true if the function returns true for every item
    *
    * filter() -- runs the given function on every item in the array and returns an array of all items for which the function
    * returns true
    *
    * forEach() -- runs the given function on every item in the array, this method has no return value
    *
    * map() -- runs the given function on every item in the array and returns the result of each function call in an array
    *
    * some() -- runs the given function on every item in the array and returns true if the function returns true for any one item
    *
    * */

    var numbers = [1, 2,3,4,5,4,3,2,1];

    var everyResult = numbers.every(function (item, index, array) {
        return (item > 2);
    });

    console.log(everyResult); // false

    var someResult = numbers.some(function (item, index, array) {
        return (item > 2);
    });
    console.log(someResult); // true

    // this code call both every() and some() with a function that return true if the given item is greater than 2
    // for every(), the result is false, because only some items fit the criteria.

    var filterResult = numbers.filter(function (item, index, array) {
        return (item > 2);
    });
    console.log(filterResult); //[3, 4, 5, 4, 3]

    var mapResult = numbers.map(function (item, index, array) {
        return item * 2;
    });
    console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]

    numbers.forEach(function (item, index, array) {
        // do something here...
    });

    /*
    * reduction method
    *
    * both methods accept two arguments: a function to call on each item and an optional initial value upon which the reduction is based
    *
    * */

    var values = [1,2,3,4,5];
    var sum = values.reduce(function (prev, cur, index, array) {
        return prev + cur;
    });
    console.log(sum); // 15
    // The first time the callback function is executed, prev is 1 and cur is 2.
    // The second time, prev is 3 (the result of adding 1 and 2), and cur is 3 (the third item in the array).
    // This sequence continues until all items have been visited and the result is returned.



    /*
    * the Date Type
    *
    * */

    var now = new Date();

    console.log(now); // Tue Nov 22 2016 16:02:42 GMT+1100 (AEDT)

    var now1 = +new Date();
    console.log(now1); // 1479791214347

    console.log(now.getMonth()); // 10
    console.log(now.getMinutes()); //
    console.log(now.getDate()); // 22


    /*
    * Function type
    *
    * functions actually are objects. each function is an instance of the Function type that has properties and methods
    * just like any other reference type. because functions are objects, function names are simply pointers to function
    * objects and are not necessary tied to the function itself.
    *
    * function defined using function-declaration syntax
    * */

    function sum(num1, num2) {
        return num1 + num2;
    }

    // this is almost exactly equivalent to using a function expression
    var sum = function (num1, num2) {
        return num1 + num2;
    };

    /*
    * because function names are simply pointers to functions, they act like any other variable containing a pointer to an
    * object. this means its possible to have multiple names for a single function.
    * */

    var anotherSum = sum;
    console.log(anotherSum(10, 10)); // 20
    sum = null;
    console.log(anotherSum(10, 10)); // 20

    // both anotherSum and sum point to the same function, even though the sum point to the null.

    /*
    * function declarations are read and added to the execution context before the code begins running through a process
    * called function declaration hoisting. as the code is being evaluated, js engine does a first pass for function
    * declarations and pulls them to the top of the source tree. so even though the function declaratioin appears after
    * its usage in the actual source code.
    *
    * */

    console.log(sum1(10, 10)); // 20
    function sum1(num1, num2) {
        return num1 + num2;
    }

//    console.log(sum2(10, 10)); // error
//    var sum2 = function (num1, num2) {
//        return num1 + num2;
//    }
// function expression can not host


    /*
    * function names are nothing more than variables, functions can be used any place any other place any other value can
    * be used. this means its possible not only to pass a function into another function as an argument but also to return
    * a function as the result of another function.
    *
    * */
    function callSomeFunction(someFunc, someArgument) {
        return someFunc(someArgument);
    }
    // this function accept two arguments. the first argument should be a function, and the second argument should be
//    a value to pass to that function.

    function getGreeting(name) {
        return "hello " + name;
    }
    var result = callSomeFunction(getGreeting, "rick");
    console.log(result); // hello rick

    /*
    * remember: access a function pointer instead of executing the function, you must leave off the parentheses, so the
    * variables add10 and getGreeting are passed into callSomeFunctioin() instead of their results being passed in.
    * */

    /*
    * returning a function from a function is also possible and can be quite useful.
    * suppose that you hava an array of objects and want to sort the array on an arbitrary object property.
    * */

    function createComparisonFunctioin(propertyName) {

        return function (object1, object2) {
            var val1 = object1[propertyName];
            var val2 = object2[propertyName];

            if (val1 < val2) {
                return -1;
            } else if (val1 > val2) {
                return 1;
            } else {
                return 0;
            }
        };
    }

    var data = [{name: "leo", age: 20}, {name: 'rick', age: 10}];
    data.sort(createComparisonFunctioin('name'));
    console.log(data[0].name); // leo

    data.sort(createComparisonFunctioin('age'));
    console.log(data[0].name); // rick

    /*
    * function internal
    *
    * arguments and this
    * arguments object has a property named callee, which is a pointer to the function that own the arguments object.
    *
    * */

    // factorial function
    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * factorial(num - 1);
        }
    }

    function factorial1(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1);
        }
    }

    /*
    * this: is a reference to the context object that the function is operating on
    * */

    window.color = 'red';
    var o = {color: 'blue'};

    function sayColor() {
        console.log(this.color);
    }
    sayColor(); //red
    o.sayColor = sayColor;
    o.sayColor(); // blue


    /*
    * function property and method
    *
    * length and prototype
    * length: indicates the number of named arguments that the function expects
    *
    * */

    function sayName(name) {
        console.log(name);
    }
    function sum3(num1, num2) {
        return num1 + num2;
    }
    function sayHi() {}

    console.log(sayName.length); // 1
    console.log(sum3.length); // 2
    console.log(sayHi.length); // 0

    /*
    * prototype property is the most interesting part of js. the prototype is the actual location of all instance methods
    * for reference types, meaning methods such as toString() and valueOf() actually exist on the prototype and are then accessed
    * from the object instances. This property is very important in terms of defining your own reference type and inheritance.
    * prototype is not enumerable and not be found using for-in
    * */

    /*
    * two methods of apply() and call()
    * they have two arguments, this, which is the object call the function
    * */

//    function sum(num1, num2) {
//        return num1 + num2;
//    }
//    function callSum1(num1, num2) {
//        return sum.apply(this, arguments);
//    }
//    function callSum2(num1, num2) {
//        return sum.apply(this, [num1, num2]);
//    }

//    console.log(callSum1(10, 10));
//    console.log(callSum2(10 ,10));

    // here this refer to window, because global object has the sum method.

//    function callSum(num1, num2) {
//        return sum.call(this, num1, num2);
//    }
//    console.log(callSum(10 ,10));

    window.color = 'red';
    var o = {color: 'blue'};

    function sayColor() {
        console.log(this.color);
    }

    sayColor(); // red
    sayColor.call(this); // red
    sayColor.call(window); // red
    sayColor.call(o); // blue

    /*
    * three special reference types are design to ease interaction with primitive values: the Boolean type, the Number type
    * and the String type.
    * each time a primitive value is read, an object of the corresponding primitive wrapper type is created behind the scene, allowing
    * access to any number of methods for manupulating the data.
    *
    * */

    var s1 = "some text";
    var s2 = s1.substring(2);
    console.log(s2); // me text

    /*
    * 1. create an instance of the String type
    * 2. call the specified method on the instance
    * 3. destroy the instance.
    *
    * this behavior allows the primitive string value to act like an object
    * */

    var num = 10.005;
    console.log(num.toFixed(2)); // 10.01

    var stringValue = "hello world";
    console.log(stringValue.charAt(1)); // e

    var result = stringValue.concat(' ok', '!');
    console.log(result); // hello world ok!

    // string wrapper type method
    var stringValue = "hello world";
    console.log(stringValue.slice(3)); // lo world
    console.log(stringValue.substring(3)); // lo world
    console.log(stringValue.substr(3)); // lo world
    console.log(stringValue.slice(3, 7)); // lo w
    console.log(stringValue.substring(3, 7)); // lo w
    console.log(stringValue.substr(3, 7)); //lo worl

    var stringValue = "  hello world ";
    var trimStringValue = stringValue.trim();
    console.log(trimStringValue); // hello world

    



</script>
</body>
</html>













































