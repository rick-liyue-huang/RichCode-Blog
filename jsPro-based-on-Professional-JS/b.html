<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<script>

    /*
    * a variable's value and data type can change during lifetime of a script
    * JS contain two different types of data: primitive values and reference values.
    * primitive type are undefined, null, boolean, number, string. These variables are said to be
    * accessed by value, because you are manipulating the actual value stored in the value.
    * reference values are objects stored in memory. when we manipulate an object, you are really working
    * on a reference to that object rather than the actual object itself. so such values are said to be accessed by
    * reference.
    * */

    /*
    * dynamic property is for reference values. when we work with reference values, we can add, change, or delete
    * properties and methods at any time.
    *
    * */

    var person = new Object();
    person.name = "Nicholas";
    console.log(person.name);
    // just remember that only reference values can have properties defined dynamically for later use.

    /*
    * copy values,
    * for primitive values, the copy value is to copy the value itself. After copying, the value will be separated
    * for reference values, the copy value is to copy the address of value, they both point to the same object.
    * the difference is that this value is actually a pointer to an object stored on the heap. two variables point to
    * exactly the same object, so changes to one are reflected on the other.
    * */

    var obj1 = new Object();
    var obj2 = obj1;
    obj1.name = "rick";
    console.log(obj2.name); // rick

    /*
    * argument passing: all function arguments in JS are passed by value, which means that the value outside of the function is
    * copied into an argument on the inside of the function the same way a value is copied from one variable to another.
    * when an argument is passed by reference, the location of the value in memory is stored into a local variable, which means that
    * changes to the local variable are reflected outside of the function.
    * */
 // this is for primitive value
    function addTen(num) {
        num += 10;
        return num;
    }

    var count = 20;
    var result = addTen(count);
    console.log(count); // 20
    console.log(result); // 30


    // this is for reference value
//    function setName(obj) {
//        obj.name = "leo";
//    }
//
//    var person = new Object();
//    setName(person);
//    console.log(person.name);

    // another sample
    function setName1(obj) {
        obj.name = "claire";
        obj = new Object();
        obj.name = "greg";
    }

    // when obj is overwritten inside the function, it becomes a pointer to a local object. that local object is destroyed as
    // soon as the function finishes executing.
    var person = new Object();
    setName1(person);
    console.log(person.name); // claire


    /*
    * determine type is for reference value
    * result = variable instanceof constructor
    * */

    // all reference value, by definition, are instance of Object
    var o = new Object();
    console.log(o instanceof Object); // true




    /*
    *  execution context: context, The context of a variable or function defines what other data it has access to,
    *  as well as how it should behave.
    *  each context has a associated variable object upon which all of its defined variables and functions exist.
    *  when an execution context has executed all of its code, it is destroyed, taking with it all of the variables and functions
    *  defined within it.
    *
    *  Each function call has its own execution context. whenever code execution flows into a function, the function's
    *  context is pushed onto a context stack. after the function has finished executing, the stack is popped, returning
    *  control to the previously executing context, this facility controls execution flow throughout an JS program.
    *
    *  when code is executed in a context, a scope chain of variable objects is created.
    *  the front of the scope chain is always the variable object of the context whose code is executing.
    *  in one word, the scope chain from the function inside to function outside.
    * */

    var color = "blue";

    function changeColor() {
        var anotherColor = "red";

        function swapColors() {
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;

            // color, anotherColor, and tempColor are all accessible here
        }

        // color and anotherColor are accessible here, but not tempColor
        swapColors();
    }

    // only color is accessible here
    changeColor();

    /*
    * an inner context can access everything from all outer contexts through the scope chain, but the outer contexts
    * cannot access anything within an inner context.
    *
    * try.. catch.. can augment the scope chain
    * */

    /*
    * no block-level scope
    *
    * */
    if (true) {
        var color = "blue"
    }
    console.log(color); // blue

    for (var i = 0; i < 10; i++) {

    }
    console.log(i); // 10;

    /*
    * JS is a garbage-collected programming environment where the developer need not be concerned with memory allocation
    * or reclamation. values that go out of scope will automatically be marked for reclamation and will be deleted during the
    * garbage-collection process.
    *
    * */




</script>
</body>
</html>





































