Effective Javascript

item 1: know which JS you are using

ECMAScript 5 strict mode is enabling in a program by adding a special string constant at the very beginning of the program.

“use strict”;

also similarly, can enable strict mode in a function by placing the directive at the beginning of the function body: 
function f(x) {
	“use strict”;
	//….
}

how to compatible the strict mode with no strict mode

by using IIFE

// no strict-mode directive
(function() {
	// file1.js
	“use strict”;
	function f() {
		//...
		}
	})();

(function () {
	//file2.js
	// no strict mode directive
	function () {
		var arguments = [];
	}
})();

Things to remember
a. decide which versions of JS your application supports
b. be sure that any JS features you use are supported by all environments where your application runs
c. always test strict code in environments that perform the strict mode checks
d. beware of concatenating scripts that differ in their expectations about strict mode.


item 2: understand JS’s floating-point number

typeof 17; typeof 98.6; typeof -2.1 // number

all numbers in JS are double-precision floating-point numbers, which means 64bit encoding of numbers
specified by the doubles. all integers from -2power53 to 2power53

most arithmetic operators work with integers, real numbers or combination of the two

The bitwise arithmetic operators, are special. they implicitly convert them to 32-bit integers, or say they are treated as 320-bit
 
8 | 1; //  9

(8).toString(2); // ‘1000’ ‘00000000000000000000000000001000’
(1).toString(2); // ‘0001’ ‘00000000000000000000000000000001’

so the result is ‘00000000000000000000000000001001’

and then parseInt(‘1001’, 2); // 9

we will find that all of the bitwise operators work the same way, converting their inputs to integers and performing their operations on the
integer bit patterns before converting the results back to stand JS floating-point numbers.

things to remember 
a. JS numbers are double-precision floating-point numbers
b. integers in JS are just a subset of doubles rather than a separate datatype
c. bitwise operators treat numbers as if they were 32-bit signed integer
d. be ware of limitations of precision in floating-point arithmetic

item 3: beware of implicit coercions

JS is a dynamically typed language, 
the arithmetic operator operators -*/ and % all attempt to convert their arguments to numbers before doing their calculation. 
the + is subtler, because it is overloaded to perform either numeric addition or string concatenation, depending on the types of its arguments
2+ 3 // 5
“hello” + “ world” // hello world

when combine a number and string? JS breaks the tie in favour of strings, converting the number to string

“2” + 3 // “23”
1 + 2 + “3” // “33”
1 + “2” + 3 // ‘123’

how to check NaN, NaN is the only JS value that is treated as unequal to itself, you can always test if a value is NaN by checking if for equality to itself
var a = NaN;
a !== a; // true

var b = “foo”;
b !== b; //false

var c = undefined;
c !== c; // false

var e = {valueOf: “foo”};
e !== e // false

we can abstract this pattern into a clearly named utility function 
function isReallyNaN(x) {
	return x !== x;
}

objects can also be coerced to primitives, this is most commonly used for converting to strings

“the Math object: “ + Math; // “the Math object: [object Math]”
"the JSON object: " + JSON; // "the JSON object: [object JSON]”

Objects are converted to strings by implicitly calling their toString method. you can test this out by calling it

Math.toString(); // “[object Math]”

Similarly, objects can be converted to number via their valueOf method

“java” + {toString: function() {return “script”}};  // “javascript”

2 * {valueOf: function() {return 3;}} // 6



Normally, JS behave the valueOf() over toString() 

so we should avoid the valueOf() method, unless your object really is a numeric abstraction and obj.toString() produces a string representation of obj.valueOf()

one kind of coercion is sometimes known as truthiness. if || and && logically work with boolean values

but accept any values.

falsy values: false 0, -0, “”, NaN, null and undefined

function point (x, y) {

	if (typeof x === “undefined”) {

	x = 320;

	}

	if (typeof y === “undefined”) {

	y = 240;

	}

	return {x: x, y: y};

}

point(); // {x:320, y:240}

point(0,0) // {x:0, y:0}



Things to remember:

a. type errors can be silently hidden by implicit coercions

b. The + operator is overloaded to do addition or string concatenation depending on its argument type

c. Objects are coerced to numbers via valueOf and to string by toString().

d. Objects with valueOf methods should implement a toString method that provides a string representation of the number produced by valueOf

e. use typeOf or comparison to undefined rather than truthiness to test for undefined values





item 4: prefer primitives to object wrapper

the five primitive type of JS are: boolean, number, string, null, undefined.

the typeof null is object, but actually it is distinct type.

At the same time, the standard library provides constructors for wrapping booleans, numbers and strings as objects.





 


















