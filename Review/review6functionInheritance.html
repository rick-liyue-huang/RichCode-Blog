<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    //Object 原型中的常用方法
    // 1. 带有下划线的除了 __proto__,其他的不考虑
    // 2. constructor 是构造函数的引用，就是构造函数

    // 3.
    var Person = function () {
        this.name = 'rick';
    };
    var p1 = new Person();
    var p2 = new Person.prototype.constructor;

    Person.prototype.init = Person;
    var p3 = new Person.prototype.init();

    // 4. hasOwnProperty
    var o = {name: 'leo'};
    function Person1() {}
    Person1.prototype = o;
    var p = new Person1();
    console.log(p.name); //leo
    var isTrue = p.hasOwnProperty('name');
    console.log(isTrue); // false

    // 5. isPrototypeOf()
    // boolean obj1.isPrototypeOf(obj2), obj1 是否是obj2的原型对象
    var Person2 = function () {};
    var p = new Person2();
    console.log(p.isPrototypeOf(Person2)); // false
    console.log(p.isPrototypeOf(Person2.prototype)); // false

    console.log(Person2.prototype.isPrototypeOf(p));  // true
    console.log(Person2.prototype.isPrototypeOf(Person2));  // false

    var o = {};
    function Person3() {}
    Person3.prototype = o;
    var p = new Person3();
    console.log(o.isPrototypeOf(p)); // true


    // 6. propertyIsEnumerable . 枚举 for-in
    var o = {};
    for (var k in o) {
        console.log(k);
    }

    // 这个方法判断属性是否可以被枚举，同时判断属性是否是自己的

    // 因此该方法表示判断属性必须是自己提供的，同时可以被枚举的，那么就返回true，否则就返回false

    // 在es3中，是对 hasOwnProperty的升级版
    // 在es5中， 引入了对象特性attribute的概念，才会使得这个方法有一些作用

    // boolean 对象.prototypeIsEnumerable(属性名称)；

    var o = {name : 'rick'};
    o.__proto__.age = 10;
    console.log(o.propertyIsEnumerable('name')); //true
    console.log(o.propertyIsEnumerable('age'));  //false


    // 7. toString, toLocaleString, valueOf
    var d = new Date();
    console.log(d.toDateString()); // Sat Dec 10 2016
    console.log(d.toLocaleDateString());  // 0/12/2016

    function Person4() {
        this.toString = function () {
            return 'toString';
        };
        this.toLocaleString = function () {
            return 'toLocalestring';
        };
    }
    var d1 = new Person4();
    console.log(d1.toString()); // toString
    console.log(d1.toLocaleString());  // toLocalestring

    // 借用方法
    console.log(toString.call(1));  // [object Number]
    console.log(toLocaleString.call(1));  //1

    console.log(new Number(1).toString());  // 1
    console.log(new Number(1).toLocaleString()); // 1

    console.log(toString.call(new Date())); // [object Date]

    // 对于对象来说，我们需要将其，有内部的方法，
    var o = {}; // valueOf
    if (!!o) {
        console.log(1); // 1
    }


    var a = [1,2,3];
    console.log(a.valueOf()); // [1, 2, 3]


    //instanceOf()
    console.log([] instanceof Array); // true

    function Fn() {}
    function Foo() {}
    var o1 = new Fn();
    console.log(o1 instanceof Foo); // false
    Fn.prototype = new Foo();
    var o = new Fn();
    console.log(o instanceof Foo); // true

    // 规律：
    /*
    * 任何的一个对象都有一条原型链，
    * 那么 只要是在该链上的构造函数，这个判断都是true
    * */


    /*
    * 创建函数的方法
    * 1. 声明式， 2. 表达式 3. new Function (这里看出函数也是对象)
    * */

    //结论： 任意的函数都是Function 的实例
    console.log( Array instanceof Function); // true
    function Pesona() {}
    console.log(Pesona instanceof Function); //true
    console.log(Date instanceof Function); // true

    console.log(Function instanceof Function);


    // new Function的语法规则
//    var 函数名 = new Function(arg1, arg2, ..., body);
//    Function 构造函数所有的参数都是字符串类型的
    // 最后一个参数也是字符串， 表示的是生成函数的函数体
    function max(a, b) {
        return a > b ? a : b;
    }
    var fnMax = new Function('a', 'b', 'return a > b ? a : b;');
    var res = fnMax(3, 5);
    console.log(res); // 5


    //写一个函数，求传入参数的和
    // 1. 有两个参数的时候
//    function sum(a, b) {
//        return a + b;
//    }
//    var fnSum = new Function ('a', 'b', 'return a + b;');
//    console.log(fnSum(4,5)); // 9

    // 多个参数的时候
    function sum() {
        var total = 0, len = arguments.length;
        for (var i = 0; i < len; i++) {
            total += arguments[i];
        }
        return total;
    }
    var res = sum(1,3,4);
    console.log(res); // 8

    var fnSum = new Function('var total = 0, len = arguments.length;' +
            'for (var i = 0; i < len; i++) {' +
        'total += arguments[i];' +
    '}' +
    'return total;');
    console.log(fnSum(2,3,5)); // 10

    // 第二种方法 吸收了MVC思想
    onload = function () {
        var fnSum = new Function();
    }





</script>
</body>
</html>


























